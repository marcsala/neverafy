import { UsersService } from '../services/users.service';
import { ProductsService } from '../services/products.service';
import { WhatsAppService } from '../services/whatsapp.service';
import { ConversationService } from '../services/conversation.service';
import { LimitsService } from '../services/limits.service';
import { PaymentsService } from '../services/payments.service';
import { AIService } from '../services/ai.service';
import { MetricsService } from '../services/metrics.service';
import { IntentService } from '../services/intent.service';
import { WhatsAppUser } from '../types/shared.types';
import { logger } from '../utils/logger';

export class MessageHandler {
  private usersService: UsersService;
  private productsService: ProductsService;
  private whatsappService: WhatsAppService;
  private conversationService: ConversationService;
  private limitsService: LimitsService;
  private paymentsService: PaymentsService;
  private aiService: AIService;
  private metricsService: MetricsService;
  private intentService: IntentService;

  constructor(
    usersService: UsersService,
    productsService: ProductsService,
    whatsappService: WhatsAppService,
    conversationService: ConversationService,
    limitsService: LimitsService,
    paymentsService: PaymentsService,
    aiService: AIService,
    metricsService: MetricsService,
    intentService: IntentService
  ) {
    this.usersService = usersService;
    this.productsService = productsService;
    this.whatsappService = whatsappService;
    this.conversationService = conversationService;
    this.limitsService = limitsService;
    this.paymentsService = paymentsService;
    this.aiService = aiService;
    this.metricsService = metricsService;
    this.intentService = intentService;
}


  async handleMessage(phoneNumber: string, message: string): Promise<void> {
    try {
      // Rate limiting check
      if (await this.isRateLimited(phoneNumber)) {
        await this.whatsappService.sendMessage(
          phoneNumber,
          "‚è∞ Vas muy r√°pido. Espera un momento antes de enviar otro mensaje."
        );
        return;
      }

      // Get or create user
      const user = await this.usersService.getOrCreateWhatsAppUser(phoneNumber);
      if (!user) {
        await this.whatsappService.sendMessage(
          phoneNumber,
          "‚ùå Error conectando con tu cuenta. Int√©ntalo m√°s tarde."
        );
        return;
      }

      // Update user activity
      await this.usersService.updateUserActivity(user.id);

      // Check for pending actions (context-based conversations)
      const context = await this.conversationService.getContext(user.id);
      if (context?.pending_action) {
        await this.handlePendingAction(user, message, context);
        return;
      }

      // Normalize message for intent detection
      const normalizedMessage = message.toLowerCase().trim();

      // Detect intent and handle accordingly
      const intent = await this.intentService.detectIntent(normalizedMessage);

      switch (intent.type) {
        case 'greeting':
          await this.handleGreeting(user);
          break;
        case 'add_product':
          await this.handleAddProduct(user, message);
          break;
        case 'list_products':
          await this.handleListProducts(user);
          break;
        case 'remove_product':
          await this.handleRemoveProduct(user, intent.extracted?.productName || '');
          break;
        case 'urgent_products':
          await this.handleUrgentProducts(user);
          break;
        case 'recipe_request':
          await this.handleRecipeRequest(user, intent.extracted?.ingredients);
          break;
        case 'premium_info':
          await this.handlePremiumInfo(user);
          break;
        case 'usage_stats':
          await this.handleUsageStats(user);
          break;
        case 'stats':
          await this.handleStats(user);
          break;
        case 'help':
          await this.handleHelp(user);
          break;
        default:
          await this.handleUnknown(user, message);
      }

      // Track message for analytics
      await this.metricsService.trackMessage(user.id, intent.type);

    } catch (error) {
      await this.handleError(phoneNumber, error);
    }
  }

  private async handleGreeting(user: any): Promise<void> {
    const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);
    const products = await this.productsService.getUserProducts(user.user_id);
    const urgent = products.filter(p => p.daysLeft <= 2);

    let message = `üëã ¬°Hola! Soy tu asistente de nevera inteligente.\n\n`;

    if (products.length === 0) {
      message += `üÜï **Para empezar, a√±ade productos:**\n`;
      message += `‚Ä¢ "Tengo leche que caduca el viernes"\n`;
      message += `‚Ä¢ "Compr√© pan integral por 2.50‚Ç¨"\n`;
      message += `‚Ä¢ "Yogures naturales hasta el lunes"\n\n`;
      message += `¬°As√≠ podr√© ayudarte a reducir el desperdicio! üå±`;
    } else {
      message += `üì¶ Tienes **${products.length} productos** en tu nevera.\n`;

      if (urgent.length > 0) {
        message += `üö® **${urgent.length} urgentes** - caducan pronto\n\n`;
        message += `üí° Escribe "urgente" para verlos\n`;
        message += `üë®‚Äçüç≥ ¬øQuieres una receta para aprovecharlos?`;
      } else {
        message += `‚úÖ Todo est√° bajo control\n\n`;
        message += `¬øEn qu√© te ayudo hoy? ü§ñ`;
      }
    }

    if (!subscription.isActive) {
      message += `\n\n‚≠ê **Premium:** Todo ilimitado + IA avanzada`;
    }

    await this.whatsappService.sendMessage(user.phone_number, message);
  }

  private async handlePendingAction(user: any, message: string, context: any): Promise<void> {
    switch (context.pending_action) {
      case 'clarify_product':
        await this.handleProductClarification(user, message, context);
        break;
      case 'confirm_removal':
        await this.handleRemovalConfirmation(user, message, context);
        break;
      case 'recipe_followup':
        await this.handleRecipeFollowup(user, message, context);
        break;
    }

    // Limpiar contexto despu√©s de manejar
    await this.conversationService.clearContext(user.id);
  }

  private async handleProductClarification(user: any, message: string, context: any): Promise<void> {
    // Intentar parsear de nuevo con el mensaje clarificado
    try {
      const product = await this.productsService.addProductByText(user.user_id, message);

      if (product) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚úÖ ¬°Perfecto! *${product.name}* a√±adido correctamente.

üìÖ Caduca: ${this.formatDate(product.expiryDate)}
üí∞ Precio: ${product.price?.toFixed(2) || '0.00'}‚Ç¨

¬°Gracias por la clarificaci√≥n! üòä`
        );
      } else {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚ùì A√∫n no pude procesar "${message}".

Prueba con este formato:
"[Producto] que caduca [fecha], [precio]‚Ç¨"

Ejemplo: "Yogur natural que caduca ma√±ana, 1.50‚Ç¨"`
        );
      }
    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error procesando el producto. ¬øPuedes intentarlo de nuevo?"
      );
    }
  }

  private async handleRemovalConfirmation(user: any, message: string, context: any): Promise<void> {
    const matches = context.context_data.matches;
    const selection = parseInt(message.trim());

    if (isNaN(selection) || selection < 1 || selection > matches.length) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        `‚ùì Por favor responde con un n√∫mero del 1 al ${matches.length}`
      );
      return;
    }

    try {
      const selectedProduct = matches[selection - 1];
      await this.productsService.removeProduct(selectedProduct.id);

      await this.whatsappService.sendMessage(
        user.phone_number,
        `‚úÖ *${selectedProduct.name}* eliminado correctamente.

¬°Espero que lo hayas disfrutado! üòä`
      );
    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error eliminando el producto. Int√©ntalo m√°s tarde."
      );
    }
  }

  private async handleRecipeFollowup(user: any, message: string, context: any): Promise<void> {
    if (message.toLowerCase().includes('s√≠') || message.toLowerCase().includes('si')) {
      // Usuario quiere la receta, verificar premium
      const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);

      if (subscription.isActive) {
        const products = context.context_data.products;
        const fullRecipe = await this.aiService.generateDetailedRecipe(products);

        await this.whatsappService.sendMessage(user.phone_number, fullRecipe);
      } else {
        await this.handlePremiumInfo(user);
      }
    } else {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "üëç Perfecto. Si cambias de opini√≥n o necesitas ayuda, ¬°aqu√≠ estoy!"
      );
    }
  }

  // M√©todos utilitarios

  private async isRateLimited(phoneNumber: string): Promise<boolean> {
    // Rate limiting b√°sico: m√°ximo 5 mensajes por minuto por n√∫mero
    // En producci√≥n usar Redis, por ahora memoria simple
    return false;
  }

  private formatDate(date: string | Date): string {
    const d = new Date(date);
    const now = new Date();
    const diffDays = Math.ceil((d.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));

    if (diffDays === 0) return 'Hoy';
    if (diffDays === 1) return 'Ma√±ana';
    if (diffDays === -1) return 'Ayer';
    if (diffDays > 0 && diffDays <= 7) return `En ${diffDays} d√≠as`;
    if (diffDays < 0 && diffDays >= -7) return `Hace ${Math.abs(diffDays)} d√≠as`;

    return d.toLocaleDateString('es-ES', {
      weekday: 'short',
      month: 'short',
      day: 'numeric'
    });
  }

  private generateUserCode(userId: string): string {
    return Buffer.from(userId.slice(-8), 'hex').toString('base64').slice(0, 6).toUpperCase();
  }

  private async handleError(phoneNumber: string, error: any): Promise<void> {
    logger.error('Message handler error:', error);

    await this.whatsappService.sendMessage(
      phoneNumber,
      "‚ùå Ups, algo sali√≥ mal. Por favor int√©ntalo de nuevo en unos momentos."
    );

    // Log error para debugging
    await this.metricsService.trackError(phoneNumber, error.message || 'Unknown error');
  }

  private async handleAddProduct(user: any, message: string): Promise<void> {
    try {
      // Check daily limit for adding products
      const productLimit = await this.limitsService.checkAndEnforceLimit(user.user_id, 'add_product');
      if (!productLimit.allowed) {
        return; // Limit service already sent the message
      }

      const product = await this.productsService.addProductByText(user.user_id, message);

      if (product) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚úÖ **${product.name}** a√±adido correctamente!

üìÖ Caduca: ${this.formatDate(product.expiryDate)}
üí∞ Precio: ${product.price?.toFixed(2) || '0.00'}‚Ç¨
üìä Categor√≠a: ${product.category}

¬°Perfecto! Tu nevera est√° actualizada üéâ`
        );

        // Track successful product addition
        await this.metricsService.trackEvent(user.user_id, 'product_added', {
          product_name: product.name,
          category: product.category,
          days_until_expiry: product.daysLeft
        });

      } else {
        // Product couldn't be parsed, ask for clarification
        await this.conversationService.setContext(user.id, {
          pending_action: 'clarify_product',
          context_data: { original_message: message },
          expires_at: new Date(Date.now() + 10 * 60 * 1000) // 10 minutes
        });

        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚ùì No pude procesar "${message}" correctamente.

**Formato recomendado:**
"[Producto] que caduca [fecha], [precio]‚Ç¨"

**Ejemplos:**
‚Ä¢ "Leche entera que caduca el viernes, 1.20‚Ç¨"
‚Ä¢ "Pan integral hasta ma√±ana"
‚Ä¢ "Yogures naturales por 2.50‚Ç¨"

¬øPuedes intentarlo de nuevo? ü§ñ`
        );
      }
    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error a√±adiendo el producto. ¬øPuedes intentarlo de nuevo?"
      );
    }
  }

  private async handleRecipeRequest(user: any, ingredients?: string[]): Promise<void> {
    try {
      // Check AI usage limit
      const aiLimit = await this.limitsService.checkAndEnforceLimit(user.user_id, 'ai_request');
      if (!aiLimit.allowed) {
        return; // Limit service already sent the message
      }

      const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);

      if (ingredients && ingredients.length > 0) {
        // User specified ingredients
        const recipe = await this.aiService.generateQuickRecipe(ingredients);
        await this.whatsappService.sendMessage(user.phone_number, recipe);
      } else {
        // Use user's products
        const products = await this.productsService.getUserProducts(user.user_id);

        if (products.length === 0) {
          await this.whatsappService.sendMessage(
            user.phone_number,
            `üì¶ Tu nevera est√° vac√≠a. A√±ade algunos productos primero:

‚Ä¢ "Tengo pollo, arroz y verduras"
‚Ä¢ "Compr√© tomates y pasta"

¬°Luego te dar√© recetas incre√≠bles! üë®‚Äçüç≥`
          );
          return;
        }

        const urgent = products.filter(p => p.daysLeft <= 3);
        const recipeProducts = urgent.length >= 2 ? urgent : products.slice(0, 5);

        if (subscription.isActive && subscription.tier === 'premium') {
          // Premium: receta completa y detallada
          const fullRecipe = await this.aiService.generateDetailedRecipe(recipeProducts);
          await this.whatsappService.sendMessage(user.phone_number, fullRecipe);
        } else {
          // Free: receta b√°sica + oferta premium
          const basicRecipe = await this.aiService.generateQuickRecipe(
            recipeProducts.map(p => p.name)
          );

          await this.whatsappService.sendMessage(user.phone_number, basicRecipe);

          // Set context for potential upsell
          await this.conversationService.setContext(user.id, {
            pending_action: 'recipe_followup',
            context_data: { products: recipeProducts },
            expires_at: new Date(Date.now() + 5 * 60 * 1000)
          });

          await this.whatsappService.sendMessage(
            user.phone_number,
            `üí° ¬øQuieres la versi√≥n completa con pasos detallados, tiempos y tips profesionales?`
          );
        }
      }
    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error generando receta. Int√©ntalo m√°s tarde."
      );
    }
  }

  private async handlePremiumInfo(user: any): Promise<void> {
    const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);

    if (subscription.isActive) {
      let message = `‚≠ê **¬°Eres Premium!** ‚ú®

`;
      message += `üöÄ **Funciones activas:**
`;
      message += `‚Ä¢ ‚úÖ Todo ilimitado
`;
      message += `‚Ä¢ ü§ñ IA avanzada y recetas completas
`;
      message += `‚Ä¢ üìä Analytics detallados
`;
      message += `‚Ä¢ üéØ Sugerencias personalizadas
`;
      message += `‚Ä¢ üí° Tips de ahorro avanzados

`;
      message += `üìÖ **V√°lido hasta:** ${subscription.expiresAt?.toLocaleDateString('es-ES')}

`;
      message += `¬°Disfruta de todas las funciones! üéâ`;

      await this.whatsappService.sendMessage(user.phone_number, message);
    } else {
      const usageStats = await this.limitsService.getUsageStats(user.user_id);
      const userCode = this.generateUserCode(user.user_id);

      let message = `‚≠ê **Upgrade a Premium** üöÄ

`;
      message += `üéØ **Con Premium obtienes:**
`;
      message += `‚Ä¢ üöÄ **Todo ilimitado** - sin l√≠mites
`;
      message += `‚Ä¢ ü§ñ **IA avanzada** - recetas completas
`;
      message += `‚Ä¢ üìä **Analytics Pro** - tendencias y insights
`;
      message += `‚Ä¢ üí° **Sugerencias personalizadas**
`;
      message += `‚Ä¢ üé® **Funciones exclusivas**

`;

      if (usageStats) {
        const dailyPercent = Math.round((usageStats.daily.used / usageStats.daily.limit) * 100);
        const weeklyPercent = Math.round((usageStats.weekly.used / usageStats.weekly.limit) * 100);

        message += `üìà **Tu uso actual:**
`;
        message += `‚Ä¢ Diario: ${usageStats.daily.used}/${usageStats.daily.limit} (${dailyPercent}%)
`;
        message += `‚Ä¢ Semanal: ${usageStats.weekly.used}/${usageStats.weekly.limit} (${weeklyPercent}%)

`;
      }

      message += `üí≥ **Solo ‚Ç¨4.99/mes**
`;
      message += `üîí **C√≥digo:** ${userCode}

`;
      message += `üí¨ **Activar:** Env√≠a "PREMIUM ${userCode}" por Bizum al 123456789`;

      await this.whatsappService.sendMessage(user.phone_number, message);

      // Schedule follow-up upsell if they're near limits
      await this.paymentsService.scheduleUpsellFollowup(user.user_id);
    }
  }

  private async handleUnknown(user: any, message: string): Promise<void> {
    // Try to parse as a product add attempt
    if (await this.intentService.couldBeProduct(message)) {
      await this.handleAddProduct(user, message);
      return;
    }

    // Check if they might be looking for a recipe
    if (await this.intentService.couldBeRecipe(message)) {
      await this.handleRecipeRequest(user);
      return;
    }

    // Generic help response
    await this.whatsappService.sendMessage(
      user.phone_number,
      `‚ùì No entend√≠ "${message}".

**Puedes probar:**
‚Ä¢ "Lista" - Ver productos
‚Ä¢ "Urgente" - Productos pr√≥ximos a caducar
‚Ä¢ "Receta" - Sugerencia de cocina
‚Ä¢ "Tengo [producto]" - A√±adir producto
‚Ä¢ "Ayuda" - Ver comandos

¬øEn qu√© te ayudo? ü§ñ`
    );
  }

  private async handleUsageStats(user: any): Promise<void> {
    const usageStats = await this.limitsService.getUsageStats(user.user_id);

    if (usageStats) {
      const dailyPercent = Math.round((usageStats.daily.used / usageStats.daily.limit) * 100);
      const weeklyPercent = Math.round((usageStats.weekly.used / usageStats.weekly.limit) * 100);
      const monthlyPercent = Math.round((usageStats.monthly.used / usageStats.monthly.limit) * 100);

      let message = `üìä **Tu uso actual**

`;
      message += `üì± **Mensajes diarios:**
`;
      message += `${usageStats.daily.used}/${usageStats.daily.limit} (${dailyPercent}%)
`;
      message += `${usageStats.daily.remaining} restantes

`;

      message += `üì¶ **Productos semanales:**
`;
      message += `${usageStats.weekly.used}/${usageStats.weekly.limit} (${weeklyPercent}%)
`;
      message += `${usageStats.weekly.remaining} restantes

`;

      message += `ü§ñ **IA mensual:**
`;
      message += `${usageStats.monthly.used}/${usageStats.monthly.limit} (${monthlyPercent}%)
`;
      message += `${usageStats.monthly.remaining} restantes

`;

      if (dailyPercent > 80 || weeklyPercent > 80 || monthlyPercent > 80) {
        message += `‚ö†Ô∏è Te est√°s acercando a los l√≠mites.
`;
        message += `‚≠ê Con Premium: *todo ilimitado*
`;
        message += `Env√≠a "premium" para m√°s info`;
      } else {
        message += `‚úÖ ¬°Vas por buen camino!`;
      }

      await this.whatsappService.sendMessage(user.phone_number, message);
    } else {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå No pude cargar tus estad√≠sticas. Int√©ntalo m√°s tarde."
      );
    }
  }

  private async handleListProducts(user: any): Promise<void> {
    try {
      const products = await this.productsService.getUserProducts(user.user_id);

      if (products.length === 0) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `üì¶ Tu nevera est√° vac√≠a.

Para empezar, a√±ade productos:
‚Ä¢ "Tengo leche que caduca el viernes"
‚Ä¢ "Compr√© pan de molde por 2‚Ç¨"
‚Ä¢ "Yogures naturales para ma√±ana"

¬°As√≠ podr√© ayudarte mejor! ü§ñ`
        );
        return;
      }

      // Ordenar por fecha de caducidad
      const sortedProducts = products.sort((a, b) => a.daysLeft - b.daysLeft);

      let message = `üì¶ *Tu nevera (${products.length} productos)*

`;

      // Productos urgentes primero
      const urgent = sortedProducts.filter(p => p.daysLeft <= 2);
      const soon = sortedProducts.filter(p => p.daysLeft > 2 && p.daysLeft <= 7);
      const fresh = sortedProducts.filter(p => p.daysLeft > 7);

      if (urgent.length > 0) {
        message += `üö® *URGENTE (${urgent.length}):*
`;
        urgent.slice(0, 5).forEach(p => {
          message += `‚Ä¢ ${p.name} - ${p.daysLeft === 0 ? 'HOY' : p.daysLeft + 'd'} (${p.price?.toFixed(2) || '0.00'}‚Ç¨)
`;
        });
        if (urgent.length > 5) {
          message += `... y ${urgent.length - 5} m√°s urgentes
`;
        }
        message += '
';
      }

      if (soon.length > 0) {
        message += `‚ö†Ô∏è *PR√ìXIMOS (${soon.length}):*
`;
        soon.slice(0, 3).forEach(p => {
          message += `‚Ä¢ ${p.name} - ${p.daysLeft}d (${p.price?.toFixed(2) || '0.00'}‚Ç¨)
`;
        });
        if (soon.length > 3) {
          message += `... y ${soon.length - 3} m√°s
`;
        }
        message += '
';
      }

      if (fresh.length > 0) {
        message += `‚úÖ *FRESCOS (${fresh.length}):*
`;
        fresh.slice(0, 2).forEach(p => {
          message += `‚Ä¢ ${p.name} - ${p.daysLeft}d
`;
        });
        if (fresh.length > 2) {
          message += `... y ${fresh.length - 2} m√°s frescos
`;
        }
      }

      const totalValue = products.reduce((sum, p) => sum + (p.price || 0), 0);
      message += `
üí∞ Valor total: *${totalValue.toFixed(2)}‚Ç¨*`;

      if (urgent.length > 0) {
        message += `

üí° ¬øQuieres una receta para aprovechar los urgentes?`;
      }

      await this.whatsappService.sendMessage(user.phone_number, message);

    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error cargando tus productos. Int√©ntalo de nuevo."
      );
    }
  }

  private async handleUrgentProducts(user: any): Promise<void> {
    try {
      const products = await this.productsService.getUserProducts(user.user_id);
      const urgent = products.filter(p => p.daysLeft <= 2);

      if (urgent.length === 0) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚úÖ *¬°Perfecto!* No tienes productos urgentes.

üéØ Productos que caducan pronto:
${products.filter(p => p.daysLeft <= 7).map(p =>
  `‚Ä¢ ${p.name} - ${p.daysLeft} d√≠as`
).join('
') || 'Ninguno'}

¬°Tienes todo bajo control! üëç`
        );
        return;
      }

      const totalUrgentValue = urgent.reduce((sum, p) => sum + (p.price || 0), 0);

      let message = `üö® *PRODUCTOS URGENTES (${urgent.length})*

`;

      urgent.forEach(p => {
        const daysText = p.daysLeft === 0 ? '¬°HOY!' : p.daysLeft === 1 ? 'MA√ëANA' : `${p.daysLeft} d√≠as`;
        message += `‚Ä¢ *${p.name}* - Caduca ${daysText}
`;
        message += `  üí∞ ${p.price?.toFixed(2) || '0.00'}‚Ç¨ ‚Ä¢ üìä ${p.category}

`;
      });

      message += `üí∏ *Valor en riesgo: ${totalUrgentValue.toFixed(2)}‚Ç¨*

`;

      message += `üí° *Sugerencias:*
`;
      message += `‚Ä¢ Cocina algo con estos ingredientes
`;
      message += `‚Ä¢ Cong√©lalos si es posible
`;
      message += `‚Ä¢ Comp√°rtelos con amigos/familia

`;

      message += `üë®‚Äçüç≥ ¬øQuieres una receta personalizada?`;

      await this.whatsappService.sendMessage(user.phone_number, message);

    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error verificando productos urgentes."
      );
    }
  }

  private async handleRemoveProduct(user: any, productName: string): Promise<void> {
    // Check l√≠mite (mismo que add_product)
    const productLimit = await this.limitsService.checkAndEnforceLimit(user.user_id, 'remove_product');
    if (!productLimit.allowed) return;

    try {
      const products = await this.productsService.getUserProducts(user.user_id);
      const matches = await this.productsService.findProductMatches(user.user_id, productName);

      if (matches.length === 0) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚ùì No encontr√© "${productName}" en tu nevera.

üì¶ *Productos disponibles:*
${products.slice(0, 5).map(p => `‚Ä¢ ${p.name}`).join('
')}
${products.length > 5 ? `... y ${products.length - 5} m√°s` : ''}

¬øPuedes ser m√°s espec√≠fico?`
        );
        return;
      }

      if (matches.length === 1) {
        // Un solo resultado, eliminar directamente
        await this.productsService.removeProduct(matches[0].id);

        await this.whatsappService.sendMessage(
          user.phone_number,
          `‚úÖ *${matches[0].name}* eliminado de tu nevera.

üí∞ Precio: ${matches[0].price?.toFixed(2) || '0.00'}‚Ç¨
üìä Categor√≠a: ${matches[0].category}

¬°Espero que lo hayas aprovechado! üòä`
        );
      } else {
        // M√∫ltiples resultados, pedir confirmaci√≥n
        await this.conversationService.setContext(user.id, {
          pending_action: 'confirm_removal',
          context_data: { matches: matches.map(m => ({ id: m.id, name: m.name })) }
        });

        let message = `ü§î Encontr√© varios productos con "${productName}":

`;
        matches.forEach((p, i) => {
          message += `${i + 1}. *${p.name}* - ${p.daysLeft}d (${p.price?.toFixed(2) || '0.00'}‚Ç¨)
`;
        });
        message += `
Responde con el n√∫mero del producto a eliminar:`;

        await this.whatsappService.sendMessage(user.phone_number, message);
      }

    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error eliminando el producto. Int√©ntalo de nuevo."
      );
    }
  }

  private async handleStats(user: any): Promise<void> {
    try {
      const products = await this.productsService.getUserProducts(user.user_id);
      const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);

      if (products.length === 0) {
        await this.whatsappService.sendMessage(
          user.phone_number,
          `üìä *Estad√≠sticas*

üì¶ Productos: 0
üí∞ Valor total: 0.00‚Ç¨

¬°A√±ade productos para ver estad√≠sticas interesantes! üìà`
        );
        return;
      }

      const totalValue = products.reduce((sum, p) => sum + (p.price || 0), 0);
      const urgent = products.filter(p => p.daysLeft <= 2);
      const avgDaysLeft = products.reduce((sum, p) => sum + p.daysLeft, 0) / products.length;

      // Estad√≠sticas por categor√≠a
      const categories = products.reduce((acc: any, p) => {
        acc[p.category] = (acc[p.category] || 0) + 1;
        return acc;
      }, {});

      const topCategory = Object.entries<number>(categories)
        .sort(([,a], [,b]) => b - a)[0];

      let message = `üìä *Tus estad√≠sticas*

`;
      message += `üì¶ Productos totales: *${products.length}*
`;
      message += `üí∞ Valor total: *${totalValue.toFixed(2)}‚Ç¨*
`;
      message += `üö® Urgentes: *${urgent.length}*
`;
      message += `üìÖ Promedio d√≠as restantes: *${avgDaysLeft.toFixed(1)}*
`;
      message += `üèÜ Categor√≠a principal: *${topCategory?.[0] || 'N/A'}* (${topCategory?.[1] || 0})

`;

      if (subscription.isActive && subscription.tier === 'premium') {
        // Estad√≠sticas premium adicionales
        const weeklyTrend = await this.productsService.getWeeklyTrend(user.user_id);
        const wasteEstimate = await this.productsService.getWasteEstimate(user.user_id);

        message += `üìà *Analytics Premium:*
`;
        message += `üìä Tendencia semanal: ${weeklyTrend > 0 ? '+' : ''}${weeklyTrend} productos
`;
        message += `üóëÔ∏è Desperdicio estimado: ${wasteEstimate.toFixed(2)}‚Ç¨/mes
`;
        message += `üí° Ahorro potencial: ${(wasteEstimate * 0.7).toFixed(2)}‚Ç¨/mes
`;
      } else {
        message += `‚≠ê *Con Premium:* Analytics avanzados, tendencias y m√°s estad√≠sticas`;
      }

      await this.whatsappService.sendMessage(user.phone_number, message);

    } catch (error) {
      await this.whatsappService.sendMessage(
        user.phone_number,
        "‚ùå Error cargando estad√≠sticas. Int√©ntalo m√°s tarde."
      );
    }
  }

  private async handleHelp(user: any): Promise<void> {
    const subscription = await this.paymentsService.checkSubscriptionStatus(user.user_id);
    const isPremium = subscription.isActive;

    let message = `ü§ñ *Ayuda - Neverafy Bot*

`;

    message += `üìù *Comandos principales:*
`;
    message += `‚Ä¢ "Tengo [producto]" - A√±adir producto
`;
    message += `‚Ä¢ "Lista" o "Qu√© tengo" - Ver productos
`;
    message += `‚Ä¢ "Urgente" - Productos a punto de caducar
`;
    message += `‚Ä¢ "Receta" - Sugerencia de cocina
`;
    message += `‚Ä¢ "Stats" - Estad√≠sticas
`;
    message += `‚Ä¢ "Premium" - Info suscripci√≥n
`;
    message += `‚Ä¢ "Uso" - Ver l√≠mites actuales

`;

    message += `üí° *Ejemplos de uso:*
`;
    message += `‚Ä¢ "Compr√© leche que caduca el viernes"
`;
    message += `‚Ä¢ "Tengo pollo, arroz y verduras"
`;
    message += `‚Ä¢ "Receta con mis productos urgentes"
`;
    message += `‚Ä¢ "Eliminar yogur natural"

`;

    if (isPremium) {
      message += `‚≠ê *Funciones Premium activas:*
`;
      message += `‚Ä¢ ‚úÖ Todo ilimitado
`;
      message += `‚Ä¢ ü§ñ IA avanzada
`;
      message += `‚Ä¢ üìä Analytics detallados
`;
      message += `‚Ä¢ üë®‚Äçüç≥ Recetas completas

`;
      message += `V√°lido hasta: ${subscription.expiresAt?.toLocaleDateString('es-ES')}`;
    } else {
      const usageStats = await this.limitsService.getUsageStats(user.user_id);
      if (usageStats) {
        message += `üìä *L√≠mites actuales (Plan Gratuito):*
`;
        message += `‚Ä¢ Mensajes: ${usageStats.daily.remaining}/d√≠a restantes
`;
        message += `‚Ä¢ Productos: ${usageStats.weekly.remaining}/semana restantes
`;
        message += `‚Ä¢ IA: ${usageStats.monthly.remaining}/mes restantes

`;
      }
      message += `‚≠ê *Upgrade a Premium* para todo ilimitado`;
    }

    await this.whatsappService.sendMessage(user.phone_number, message);
  }
}
